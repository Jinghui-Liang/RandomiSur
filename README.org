#+PROPERTY: :mkdirp yes

* About

Reaction time (RT) for items in psychometric questionnaires reflect participants' immediate mental status during thier response processes. Yet none of the popular data collection platforms allow collecting individual RT for each item. This demo provides an environment to collect such data based on various programming languages (R / JavaScript / PHP / HTML) that interactively work. It also contains randomized and pseudorandomized design strategies to organize the presentation order of a questionnaire in order to explore item effects and sequential effects in psychometric survey.

** Quick start

To download this platform with default setting, put the lines below in termianl (or command prompt on Windows)
#+begin_src shell :results silent
git clone https://github.com/Jinghui-Liang/rt_survey_demo.git
cd rt_survey_demo
#+end_src

*** TODO (new)Launching your platform on server

This platform uses =.env= file to setup all connection configuration. The default setting is

#+begin_src text :tangle .env
HTTP_PORT=8080
SQL_PORT=3306
SERVER_NAME=php2
DB_NAME=db2
DB_PASS=example
MARIADB_VER=10.4
#+end_src

This config allow you to test everything with your local machine. Open =.env= with a editor you like and change the config to the corresponding values you have on the server. 
For Emacs user, use =C-c C-v C-t= to tangle changes with this block. Then call this R function 

#+begin_src shell
Rscript R/db_conf.R
#+end_src

Build a docker container as development environment

#+begin_src shell
docker-compose up -d --build
#+end_src

For Emacs user, if you are reading this README with org mode, you will find a call function =#+CALL: create-db-conf()= here. Execute it by key binding =C-c C-c= to generate a conf file to make sure that all the ports and names match.

#+CALL: create-db-conf()
Then execute the binary on shell by

#+begin_src shell
./ConfigDB
#+end_src

which will ask you the name of database and the length of questionnaire. Also, this binary asks if this test is about to load server or local config.

When you see =DONE= displayed on shell and if

1) you are running local test, you can log in to your survey on your browser by =127.0.0.1:8080= (All users) or =localhost:8080= (MacOS and Linux users only). The corresponding database can be accessed by shell command =mysql -h 127.0.0.1 -u root -P 3306 -p=, with password =example=.
2) you are about to run this platform online, you can upload the =www= folder to your server (located on =./server/www=) and you are good to go.

When (TODO) *FINISHING* your survey, use the following command line to reset the survey

#+begin_src shell
Rscript R/reset_counter.R
#+end_src

* Setting up the server

** Dockerfile

#+begin_src text :tangle server.Dockerfile
FROM php:8.1.1-apache
RUN docker-php-ext-install mysqli pdo pdo_mysql
#+end_src

** Docker-compose

#+begin_src yaml :tangle docker-compose.yml
version: '3.1'

services:
  php:
    build:
      context: .
      dockerfile: server.Dockerfile
    container_name: ${SERVER_NAME}
    ports:
      - ${HTTP_PORT}:80
    links:
      - "db:database"
    restart: always
    volumes:
      - ./server/www:/var/www/html/
  db:
    container_name: ${DB_NAME}
    image: mariadb:${MARIADB_VER}
    ports:
      - ${SQL_PORT}:3306
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASS}
#+end_src

* Initialize database using R

** One system file to generate the database and tables

You might already have corresponding database set up on a server. However if you want to test or modify anything on your local machine, this binary will automatically set up a database.

#+begin_src R :shebang "#!/usr/bin/env Rscript" :tangle-mode (identity #o755) :tangle ConfigDB_server

prompt1 <- "Please type the name of your questionnaire (in abbreviative form) "
prompt2 <- "Please type the length of your questionnaire "
prompt3 <- "local or server config?"
cat(prompt1)
qname <- readLines("stdin", n = 1)
cat(prompt2)
qlen <- readLines("stdin", n = 1) |> as.integer()
cat(prompt3)
position <- readLines("stdin", n = 1)
cat ("Arguments accepted, inatialising ......")

if (position == "local") {
  source ("R/init_db.R")}
source ("R/init_table.R")
source ("R/init_trial.R")
source ("R/insertProc.R")

cat("DONE")

#+end_src

** Database

If you are testing on your local machine you need to manually set up the database
#+begin_src R :tangle R/init_db.R
if (interactive()) {
  qname <- "test"
} else {
  qname <- qname}

readRenviron(".env")

con <- DBI::dbConnect(
              RMariaDB::MariaDB(),
              host = '127.0.0.1',
              port = Sys.getenv('SQL_PORT'),
              user = 'root',
              password = Sys.getenv('DB_PASS')
            )

stmt_db <- paste ('CREATE DATABASE', qname)

DBI::dbSendStatement(con, stmt_db)

DBI::dbDisconnect(con)
#+end_src

** Tables for storing data and recording id-order pairs

*** Create table for response data and send it to mysql.
#+begin_src R :tangle R/init_table.R
readRenviron(".env")

if (position == "local"){
  con_t <- DBI::dbConnect(
                  RMariaDB::MariaDB(),
                  host = '127.0.0.1',
                  port = Sys.getenv('SQL_PORT'),
                  user = 'root',
                  password = Sys.getenv('DB_PASS'),
                  dbname = qname ## 'qname' has been defined in 'init_db.R'
                )
} else if (position == "server"){
  con_t <- DBI::dbConnect(
                  RMariaDB::MariaDB(),
                  host = Sys.getenv('SERVER_NAME'),
                  port = Sys.getenv('SQL_PORT'),
                  ## user = 'tlabusr',
                  password = Sys.getenv('DB_PASS'),
                  ## dbname = 'IPIP'
                )} else {
                   stop ('arguments must be either "local" or "server"')}
query <- "CREATE OR REPLACE TABLE response (
      p_id VARCHAR(999), 
      rt VARCHAR(999), 
      response VARCHAR(999), 
      Q_num VARCHAR(999), 
      trial_type VARCHAR(999), 
      trial_index VARCHAR(999), 
      order_index VARCHAR(999),
      time_elapsed VARCHAR(999), 
      internal_node_id VARCHAR(999)
      )"

DBI::dbSendQuery(con_t, query)
#+end_src

*** Create table for recording presentation order in R.

#+begin_src R :results silent :tangle R/generate_order.R
options (tidyverse.quiet = TRUE)
library (tidyverse)
set.seed (666) ## since it would be sourced by other scripts it should be reproducible.

## Method to generate a Latin-Square

latin_template <- function(n){

  lat_sq <- array (rep (seq_len (n), each = n), c (n, n))
  lat_sq <- apply (lat_sq - 1, 2, function (x) (x + 0:(n-1)) 
                   %% n) + 1

  return(lat_sq)
}

## Generate a table including all the presentation order we want, and make it suitable for JavaScript.
p_order_table <- function (qlen, rd.size = qlen) {
  if (isTRUE (rd.size >= factorial(qlen))) {
    stop ("number of expected randomzied order exceeded the maximum possible arrangments")
  } else {
    fx <- as_tibble (t ((1 : qlen)))
    ls <- as_tibble (latin_template (qlen))
    rd <- as_tibble (t (replicate (rd.size, sample (1: qlen, qlen, FALSE), TRUE)))

    ls_label <- paste0 (rep ("ls", length (ls)), 1:length (ls))
    rd_label <- paste0 (rep ("rd", rd.size), 1: rd.size)
    order_label <- c ("fx", ls_label, rd_label)
    position_label <- paste0 ("p", 1: qlen)

    dat <- (bind_rows (fx, ls) %>% bind_rows (rd) - 1)

    order_table <- tibble (order_label = order_label) %>% bind_cols (dat)
    colnames (order_table) [2: (qlen + 1)] <- position_label
    return (order_table)
  }
}

o.record <- p_order_table (qlen)

f.record <- tibble (
  order_label = o.record$order_label,
  n = rep (0)
)

match.record <- tibble (p_id = "0",
                        order_label = "0")
match.record <- match.record[-1, ]

#+end_src
  
*** Send tables to mysql using Terminal (or Common Prompt in Windows)

#+begin_src R :tangle R/init_trial.R
source ("./generate_order.R")

DBI::dbWriteTable (con_t, "order_list", o.record, overwrite = TRUE)
DBI::dbWriteTable (con_t, "frequency_counter", f.record, overwrite = TRUE)
DBI::dbWriteTable (con_t, "order_match", match.record, overwrite = TRUE)

query <- paste ("ALTER TABLE", "order_match", "MODIFY order_label VARCHAR(999)", sep = " ")

rs <- DBI::dbSendStatement (con_t, query)
DBI::dbClearResult (rs)

query <- paste ("ALTER TABLE", "order_match", "MODIFY p_id VARCHAR(999)", sep = " ")

rs <- DBI::dbSendStatement (con_t, query)
DBI::dbClearResult (rs)


query <- paste ("CREATE OR REPLACE TABLE", "demo", "(
    p_id VARCHAR(999),
    age VARCHAR (999), 
    gender VARCHAR(999) 
    )")

rs <- DBI::dbSendStatement (con_t, query)
DBI::dbClearResult (rs)

#+end_src

** Insert and store procedure (to handle with accepted data) in MySQL

#+begin_src R :tangle R/insertProc.R

query <- "CREATE OR REPLACE PROCEDURE insertLikertResp(IN json VARCHAR(9999))
    INSERT INTO response (p_id, rt, response, Q_num, trial_type, trial_index, order_index, time_elapsed, internal_node_id)
    VALUES(
      JSON_EXTRACT(json, '$.p_id'),
      JSON_EXTRACT(json, '$.rt'),
      JSON_EXTRACT(json, '$.response'),
      JSON_EXTRACT(json, '$.Q_num'),
      JSON_EXTRACT(json, '$.trial_type'),
      JSON_EXTRACT(json, '$.trial_index'),
      JSON_EXTRACT(json, '$.order_index'),
      JSON_EXTRACT(json, '$.time_elapsed'),
      JSON_EXTRACT(json, '$.internal_node_id')
   )"

rs <- DBI::dbSendStatement (con_t, query)
DBI::dbClearResult (rs)

DBI::dbDisconnect(con_t)

#+end_src

* Web

** Backend

*** TODO Mariadb config

figure out how to generate dbname from =.env=

#+begin_src R :results silent :tangle R/db_conf.R
readRenviron(".env")

template <- "[database]\ndriver = mysql\nhost = %s\nport = %s\ndbname = ipip\nusername = root\npassword = %s"

conf <- sprintf(template, Sys.getenv('DB_NAME'), 3306, Sys.getenv('DB_PASS'))

writeLines(conf, 'server/www/private/conf.ini')
#+end_src

*** PHP connection class
#+begin_src php :tangle server/www/private/dbConnect.php
<?php
class dbConnect {
    private $pdo = null;
      
    public function getPDO(){
        return $this->pdo;
    }
      
    public function __construct(){
        try {
            $conf = parse_ini_file(__DIR__ . '/conf.ini', true);
            $dsn = sprintf('mysql:host=%s;port=%s;dbname=%s', $conf['database']['host'], $conf['database']['port'], $conf['database']['dbname']);
            $username = $conf['database']['username'];
            $password = $conf['database']['password'];
      
            $this->pdo = new PDO($dsn, $username, $password);
            // set the PDO error mode to exception
            $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        } catch(PDOException $e) {
            echo "<script>console.log('Connection failed: " . $e->getMessage() . "')</script>";
        }
    }
}
?>
#+end_src

*** htaccess
#+begin_src text :tangle server/www/private/.htaccess
<Location />
Order deny, allow
</Location>
#+end_src  

*** php scripts

Rely on fetch API mostly. The code here works but might not be efficient enough (I know...). Please help improving if you are willing to.

**** match_order.php

change =where n<1= in =$query= to set how many times each presentation order is assigned you want.
#+begin_src php :tangle server/www/match_order.php
<?php
require_once(__DIR__ . '/private/dbConnect.php');
$dbCon = new dbConnect();
$pdo = $dbCon->getPDO();

$json_string = json_decode(file_get_contents('php://input'), true);

$query = "SELECT * FROM order_list WHERE order_label IN
                          (SELECT order_label FROM frequency_counter WHERE
                             (CASE
                                WHEN (select (select n from frequency_counter where order_label = 'fx') < 50)
                                  THEN order_label = 'fx' OR (order_label != 'fx' AND n < 2)
                                ELSE order_label != 'fx' AND n < 2
                              END)
                           )
                        ORDER BY RAND() LIMIT 1";

try{
    $sth = $pdo->query($query);

    $result = $sth->fetchAll(PDO::FETCH_ASSOC);

    header('Content-Type: application/json; charset=utf-8');
    echo json_encode($result);

} catch (PDOException $e) {
    http_response_code (500);
    echo $e-> getMessage ();
};

?>
#+end_src

**** postData.php
#+begin_src php :tangle server/www/postData.php
<?php
require_once(__DIR__ . '/private/dbConnect.php');
$dbCon = new dbConnect();
$pdo = $dbCon->getPDO();

$json_string = json_decode(file_get_contents('php://input'), true);
       
try{

    $sql_proc = 'CALL ' . $json_string['proc_method'] . '(?)';

    $sth = $pdo->prepare($sql_proc);

    foreach ($json_string['json_trials'] as $x) {
        $sth->bindValue(1, json_encode($x), PDO::PARAM_STR);
        $sth->execute();
    };

    echo 'success';

}catch(PDOException $e){
    http_response_code(500);
    echo $e -> getMessage();
};
#+end_src

**** postMatch.php
This is VERY important since it records which participant received which presentation order. The subsquent assignment of orders will rely on this record (which is also my research goal).

#+begin_src php :tangle server/www/postMatch.php
<?php
require_once(__DIR__ . '/private/dbConnect.php');
$dbCon = new dbConnect();
$pdo = $dbCon->getPDO();
       
$json_string = json_decode(file_get_contents('php://input'), true);
       
try {    
    $data = array(
        ':p_id' => $json_string['p_id'], 
        ':order_label' => $json_string['order_label']
    );
    $test = $json_string['order_label'];
    

    // -- new here
    $email = array(
        ':p_id' => $json_string['p_id'], 
        ':email' => $json_string['email']
    );
    // -- new ends
       
    // change table names in the code below when use questionnaires with different length.
       
    $querya = "INSERT INTO order_match (p_id, order_label) VALUES (:p_id, :order_label)";
    $stmt = $pdo->prepare($querya);
    $stmt->execute($data);
       
    $queryb = "UPDATE frequency_counter SET n = n + 1 WHERE order_label = ?";
    $stmt = $pdo->prepare($queryb);
    $stmt->execute([$test]);
 
    $queryc = "INSERT INTO email (p_id, email) VALUES (:p_id, :email)";
    $stmt = $pdo->prepare($queryc);
    $stmt->execute($email);

    echo 'success';
       
} catch(PDOException $e) {
    http_response_code(500);
    echo $e -> getMessage();
};
?>
#+end_src

**** postDemo.php

#+begin_src php :tangle :tangle server/www/postDemo.php
<?php
require_once(__DIR__ . '/private/dbConnect.php');
$dbCon = new dbConnect();
$pdo = $dbCon->getPDO();
  
$pdo = $dbCon->getPDO();

$json_string = json_decode(file_get_contents('php://input'), true);

try {    
    $data = array(
        ':p_id' => $json_string['p_id'], 
        ':age' => $json_string['age'],
        ':gender' => $json_string['gender']
    );

    $query = "INSERT INTO demo (p_id, age, gender) VALUES (:p_id, :age, :gender)";
    $stmt = $pdo->prepare($query);
    $stmt->execute($data);

    echo 'demo post success';

} catch(PDOException $e) {
    http_response_code(500);
    echo $e -> getMessage();
};

?>
#+end_src

** Front end

*** index.php
#+begin_src html :tangle server/www/index.php
<!DOCTYPE html>
<html>
  <head>
    <title> Behaviour Survay </title>
    <script src="https://unpkg.com/jspsych@7.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-likert@1.0.0"></script>
    <style>
      .jspsych-btn {
      margin-bottom: 10px;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://unpkg.com/jspsych@7.0.0/css/jspsych.css"
      />
    <link rel="shortcut icon" href="#"/>  <!-- remove it in production -->
  </head>
  <body></body>
  <!-- use module.js to connect js scripts. -->
  <script type = "module" src= "test-survey.js"> </script>
</html>

#+end_src

*** que-3.js
A short questionnaire with 3 items just for testing.
In formal survey you can add parameter =required: TRUE= right after =labels: likert= to force participants to answer the question displayed.
#+begin_src js :tangle server/www/que-3.js
  // When specifying the Q-num, use strings "01" to "09" to match the presentation order.

  var instru = `how you feel like you are a...`;
  var likert = ["Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"];
  var trials = [];

  var start = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<p>Welcome to this behaviour survey, please press "start" to continue</p>',
      choices: [`Start`],
      data: { Q_num: `start` }
  };

  var blank = {
      type: jsPsychHtmlButtonResponse,
      stimulus: 'Press "Start" again to begin the survey',
      choices: [`Start`],
      data: { Q_num: 0 }
  };

  var show_data = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `that's the end of this survey,thanks for your participation.`,
      choices: ['Show results'],
      data: { Q_num: `drop` }
  };

  var Q1 = {
      type: jsPsychSurveyLikert,
      questions: [{
    prompt: "Q1.",
    labels: likert
      }],
      preamble: instru,
      data: { Q_num: `01`}
  };

  trials.push (Q1);

  var Q2 = {
      type: jsPsychSurveyLikert,
      questions: [{
    prompt: "Q2.",
    labels: likert
      }],
      preamble: instru,
      data: { Q_num: `02`}
  };

  trials.push (Q2);

  var Q3 = {
      type: jsPsychSurveyLikert,
      questions: [{
    prompt: "Q3.",
    labels: likert
      }],
      preamble: instru,
      data: { Q_num: `03`}
  };

  trials.push (Q3);

  export { start, blank, trials, show_data };

#+end_src

*** test-survey.js

Since I used =async= funtion to assign presist presentation orders, the whole survey and related customized functions are needed to be wrapped into the resolve callback function.
#+begin_src js :tangle server/www/test-survey.js

// ------- Functions to set up database connection ----------

const getData = async (data, uri) => {
    const settings_get = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    };
    try {
        const fetchOrder = await fetch(uri, settings_get);
        const data = await fetchOrder.json();
        return data;
    } catch (e) {
        console.log(e);
    }
};

const getOrder = async () => {
    let data = await getData({}, 'match_order.php');
    return data;
};

// --------- Setting up questionnaire. -------------
// import { start, blank, trials, show_data } from './que-6.js';
import { start, blank, trials, show_data } from './que-3.js';
console.log (trials);
// --------- Initializing jsPsych and posting response to database ----------

const postData = async (data, uri) => {
    const settings_post = {
	method: 'POST',
	headers: {
	    Accept: 'application/json',
	    'Content-Type': 'application/json'
	},
	body: JSON.stringify(data)
    };
    try {
	const fetchResponse = await fetch(uri, settings_post);
	const data = await fetchResponse.json();
	console.log (data);
	return data;
    } catch (e) {
	console.log(e);
    }
};

let promiseSuccess = (data) => {
    if (data.length == 0) {
	document.write ('all presentation orders are fully assigned, please run "Rscript reset_counter.R" in terminal to run this survey again');
	throw 'all presentation orders are fully assigned, please run "Rscript reset_counter.R" in terminal to run this survey again';
    } else {
    var order_label = Object.values (data[0]);
    let order = order_label.slice (1, order_label.length).map (x => x + 1);
    
    if (order.length < 10) {
	var order_str = order.map (i => "0" + i);
    } else {
	for (j; j <= order.length - 1; j++) {
	    let element = order[j];
	    if (element.length == 1) {
		temp = "0" + element;
		order_str.push (temp);
	    } else {
		order_str.push (order[j]);
	    }
	}
    };
    };

// use async function to get presentation order from mysql
    
var jsPsych = initJsPsych({
    on_finish: function () {
	var p_id = jsPsych.randomization.randomID(4);
	jsPsych.data.addProperties({order_index: method,
				    p_id: p_id});
	var match = {
	    p_id: p_id,
	    order_label: method
	};
	console.log (match);
	let json = jsPsych.data.get()
	    .filterCustom(trial => trial.trial_type == 'survey-likert')
	    .ignore('question_order');
	let json_trials = json.trials.map(x => {
	    let question = Object.keys(x.response)[0];
	    let response = x.response[question];
	    return ({
		p_id: x.p_id,
		rt: x.rt,
		response: x.response,
		Q_num: x.Q_num,
		trial_type: x.trial_type,
		trial_index: x.trial_index,
		order_index: x.order_index,
		time_elapsed: x.time_elapsed,
		internal_node_id: x.internal_node_id
	    })
	});
	document.write (json_trials[0]);
	console.log (json_trials[0]);
	let trial_data = {
	    json_trials: json_trials,
	    proc_method: 'insertLikertResp'
	};
	postData (match, 'postMatch.php');
	postData (trial_data, 'postData.php');
	console.log(JSON.stringify(trial_data));
    }
});

// ----------- Reorganize questions based on the given order. -------------
    
    var new_order = []; 
    var v = 0;
    var id = 0;
    console.log (trials[id].data);
    for (v; v < order_str.length; v++) {
	while (trials[id].data.Q_num != order_str[v]) {
	    id++;;
	}
	new_order.push (trials[id]);
	id = 0; // repeatly matching.
    };
    console.log (order_label);
    console.log (new_order);
    var method = order_label [0];
    var fin_order = {timeline: new_order};
    jsPsych.run([start, blank, fin_order, show_data]); 
};

var presOrder = getOrder();

presOrder.then(promiseSuccess, (err) => {
    console.log(error);
});

#+end_src

*** Reset the frequenct counter using R

After all presentation orders are fully assigned, you need to turn back to terminal (or command prompt on Windows) to reset the counter by execute a R script if you want to enlarge the sample

#+begin_src R :tangle R/reset_counter.R 
qname <- commandArgs (TRUE)

readRenviron(".env")

con <- DBI::dbConnect(
              RMariaDB::MariaDB(),
              host = '127.0.0.1',
              port = Sys.getenv('SQL_PORT'),
              user = 'root',
              password = Sys.getenv('DB_PASS'),
              dbname = qname
            )

query <- "update frequency_counter set n = 0"

rs <- DBI::dbSendStatement (con, query)
DBI::dbClearResult (rs)
DBI::dbDisconnect (con)
#+end_src

* Analysis

** Checkresponse
Run the following code in terminal (or command prompt on Windows), type the length of the questionnaire to check the corresponding tables (e.g., if your questionnaire is 6-item long, type =Rscript R/check_response.R 6=). Actually the only table we need to focus is =que_rd_test_n= but it's sometimes useful to see the other record.
#+begin_src R :tangle R/check_response.R
qname <- commandArgs (TRUE)

readRenviron(".env")
library(DBI)
library(tidyverse)

con_t <- DBI::dbConnect(
                RMariaDB::MariaDB(),
                host = '127.0.0.1',
                port = Sys.getenv('SQL_PORT'),
                user = 'root',
                password = Sys.getenv('DB_PASS'),
                dbname = qname
              )



response <- tbl (con_t, "response") %>%
  collect()

frequency <- tbl (con_t, "frequency_counter") %>% 
  collect ()

order <- tbl (con_t, "order_list") %>% 
  collect ()

match <- tbl (con_t, "order_match") %>%
  collect ()


dbDisconnect(con_t)
head (response)
head (frequency)
head (order)
head (match)

#+end_src

* Citation

.cff files
#+begin_src text :tangle ./CITATION.cff
cff-version: 1.2.0
title: >-
  Detecting Item and Sequential Effects in
  Psychometric Surveys: A Demo Platform
message: >-
  If you use this software, please cite it using the
  metadata from this file.
type: software
authors:
  - given-names: Jinghui
    family-names: Liang
  - given-names: Alistair
    family-names: Beith
  - given-names: Dale
    family-names: Barr
version: 1.0.0
date-released: 2022-04-30
url: "https://github.com/Jinghui-Liang/rt_survey_demo.git"
#+end_src
